/**********************************************************
* Project 2: CalcYouLater
* CS 15: Data Structures
* README
* Author: Dan Glorioso (dglori02)
* Date: 10/23/2023
*
*********************************************************/


B. Program Purpose:
    The purpose of this program is to implement a Reverse Polish Notation
    (RPN) calculator. The program will take in a file or cin input of number,
    bools, or strings onto a data structure with the functionality of a stack 
    and perform operations on the input. The program will also be able to
    handle errors in invalid input and print out error messages.


C. Acknowledgements: 
    I worked on this project independetly. The design for my DatumStack class
    is based on the vector spec from cplusplus.com 
    (https://cplusplus.com/reference/vector/vector/). I used this resource to 
    check the various built-in functions that I could call on to implement my 
    own class that acts like a stack. For my istream library implementation, I 
    used the istream spec from cplusplus.com 
    (https://cplusplus.com/reference/istream/istream/) to check
    the various built-in functions that I could call on to implement my own
    class and the provided example of how to initalize an istream object. My
    exec() function uses the rstring as an istringsteam, so I used the 
    cplusplus.com (https://cplusplus.com/reference/sstream/istringstream/)
    website again to reference this implementation. For my file reading, I 
    referenced the open_or_die function shown in lecture. I also referenced
    the exception mini-lecture to check how to try and catch exceptions in 
    both my unit testing framework and my run_helper function.


D. Files: 

main.cpp:
     Main function for the RPN calculator program. The main driver of the
     program that can take in a file or cin input and perform operations on
     the input.

RPNCalc.cpp:
    Main implementatino of the RPN calculator. Implementation of the RPNCalc 
    class that includes a DatumStack object and functions to manipulate the 
    stack. Functions include run, run_operation, run_inequality, got_int, 
    parseRString, divide, mod, numIn, boolIn, not_command, print, dup, swap, 
    printError, checkEmpty, rstring_command, exec. This implementation also 
    contains a query loop that reads in commands from an istream until "quit"
    or the end of the input is reached. 

RPNCalc.h:
    Declaration of the RPNCalc class and its functions that are used in the 
    RPNCalc program, which include run, run_operation, run_inequality, got_int, 
    parseRString, divide, mod, numIn, boolIn, not_command, print, dup, swap, 
    printError, checkEmpty, rstring_command, exec.

DatumStack.cpp:
    Implementation of the DatumStack class that acts as a stack data structure
    for the RPNCalc program. Functions include push, pop, top, size, clear, 
    empty, print, and swap.

DatumStack.h:
    Declaration of the DatumStack class and its functions that are used in the 
    RPNCalc program, which include push, pop, top, size, clear, empty, print, 
    and swap.

unit_test.h:
     Framework to test the functionality of the DatumStack class 
     and parser function using unit_test testing. 

Makefile:
     Makefile compiles the program with the command "make CalcYouLater"

README:
     This file.

commands_test.cyl:
    File that contains basic commands to test the functionality of the RPNCalc 
    program. Tests by adding numbers to the stack, performing operations on
    the stack, and printing the stack, as well as testing unimplemented
    command inputs.

complext_test.cyl:
    File that contains more complex commands to test the functionality of the 
    RPNCalc program. Tests by adding numbers, booleans, and strings to the 
    stack, performing operations on the stack that include operations within
    string and if statements on condtions that apply and do not apply. This
    file also tests nested if statements.

operations_test.cyl:
    File that contains basic math operations to test the functionality of the 
    RPNCalc program with numbers inputted. Tests by performing the specified
    operations on the numebrs inputted and printing the current stack. Also 
    tests a few of the commands on the numbers.

inequality_test.cyl:
    File that contains basic inequality operations to test the functionality
    of the RPNCalc program with numbers inputted. Tests by pushing numbers
    onto the stack and then performing the specified inequality operations on
    them and printing the results that are on top of the stack.

file_test.cyl:
    File that conatins commands to test the functionality of the RPNCalc
    program with a file input. Tests by reading in a file and executed the
    opertaions within the file. Also tests that the whole program will quit
    if quit is reached on a file input. Also test opening an invalid file.

invalid_test.cyl:
    File that contains invalid commands to test the functionality of the
    error message printing of the RPNCalc program. Tests by inputting invalid
    commands that should not be recognized by the program and printing the
    appropriate error message.


E. Compile/run:
     - Compile using
            make CalcYouLater
     - run executable with
            ./CalcYouLater 


F. Data Structures:
     The primary data structures used in this program is the vector of
     Datum in the DatumStack class that acts as a stack data structure that 
     can hold numbers, booleans, and strings and perform necessary operations
     on the items in the "stack" starting from the top of the stack. Within the 
     private member variables of the declaration of the DatumStack class is a 
     vector of Datum called stack. Within the DatumStack.cpp implementation, 
     this vector is used to manipulate and perform operations on the items in
     the stack starting from and adding to the back. I used the built in 
     std::vector to implement this stack. Using std::vector to implement the
     stack functionality made it easily to adapt between the two data
     structure types since some similar functions are already built in to the
     vector class. For example, the push, pop_back, size, and clear function 
     is the same for both, so this made it easy for me to implement these 
     commands in my DatumStack class. This stack form of data structure is
     useful because it allows intermediate results of the calculator to be 
     stored in a location that is easily accessible by the next operation. 
     With RPN, the operations are performed on the top two items of the stack,
     so this data structure allows for easy access to these items since it does
     not need to go through all of the other Datum objects in the stack to 
     access the ones that the operation is going to be performed on. Once the
     operation is performed, the result is easily pushed back onto the stack
     for use in the next operation. This data structure also allows for easy
     access to the top of the stack, which is useful for printing the stack
     and checking if the stack is empty. RPN does not use parentheses, so this
     data structure is useful because it does not need to keep track of the
     order of operations. The operations are performed on the top two items of
     the stack, so the order of operations is already determined by the order
     of the items in the stack. The downside to using a stack is that you 
     cannot access the elements at the bottom without first accessing the 
     elements on top, but in certain circumstances, like this one, that is not 
     a problem since you never need to access the objects below the top of the
     stack. In other situations, a stack could be useful 
     when implementing a recursive algoritm that needs to keep track of the
     intermediate results or previous results from the recursive calls. The 
     top of the stack would contain the result of the most recent call and then
     with each recursive call, the result would be pushed onto the stack.
     The stack data structure is also useful when implementing a depth-first
     search algorithm because it allows for easy access to the most recently
     added object to the stack, which would be at the top. Once the search has 
     reached as far as possible, it must back-track and the stack is a good
     way of keeping the backward order of which nodes it has gone to so far. 


G. Testing:
    My initial testing during phase 1 of this project consisted primarily of
    using the unit_test testing framework in the unit_test.h file. This testing
    was used to test my DatumStack and parseRString classes as I built them.
    Starting with a dummy test, I slowly added more tests for every constructor
    or function that I added to the class. After implemented a new function, 
    I would write one function that tests the basic operation of the function
    and then compile and run unit_test to ensure it was working as intended. 
    Then, I added 3-4 more tests for each function that tested with more input,
    empty inputs, and edge cases or error checking cases. I used the assert
    statement to check that the output of the function was what I expected. 
    I tested my parseRString function by first testing the basic operation
    of the function by inputting a string and checking that the output was
    the same as the input with a starting curly brace. Then, I added more tests
    that tested the function in situations where the input was valid, invalid,
    and contained nested curly braces to test that the braceCounter was
    accurately keeping track of the number of curly braces. Note that my 
    parseRString function is now within the RPNCalc class, but was
    originally in its own class during testing and phase 1. Aftward, I moved
    to my RPNCalc class and tested as I implemented. Using the advise in the
    spec, first started with my run() function that only accepts quit as a
    command. I tested this by inputting quit and checking that the program
    exited properly and printed the same output as the demo. Then, as the spec
    mentions, I create the functionality of reading in a number of items and
    just printing them using the print function. To ensure my program was
    correclty taking in input and printing output to the correct output, I 
    started creating a test file called "commands_test.cyl" that was very basic
    commands that I could use with both my program and the demo program to
    compare my output. I redirected the input and output of the program command
    using the command "./CalcYouLater < commands_test.cyl > my_out.out" and 
    then compared my output to the demo output using the command 
    "./theCalcYoulater < commands_test.cyl > out.out". Then, I would diff
    the two outputs to ensure the programs are acting the same. As I
    implemented the basic math operations and basic RPNCalc commands, I would
    run the same process, creating two outputs and diffing the two to ensure
    they were the same. I also created the testing file "operations_test.cyl" 
    that inputs basic math operations and then checks that they are the same. 
    Once I implemented inequality, I create the testing file 
    "inequality_test.cyl" that inputs very basic inequality operations and then
    compares the output to the demo output. My testing file "complex_test.cyl"
    tests rstring and the if function once I implemented those. Some of the 
    inputs in the file are from the spec, so I knew how the output should
    behave. At the end when I implemented my file function, I created the
    testing file "file_test.cyl" that tests the functionality when rstrings
    of files were executed. Within these files, I includes other files to 
    test how they would operate when a series of files were called. Once edge
    case I test in this file is checking that the program will quit when a
    file is called the contains a "quit". Since my file, run_helper, and
    run_query functions are all bools, this worked since it triggers a false
    return if a quit within an input file is reached. Again, I compared the
    output of this to that of the demo program. Finally, I created the testing
    file "invalid_test.cyl" that tests the error message printing of the
    program in edge case or invalid input scenarios. This file tests operations
    that are some of my edge cases, including calling functions on the wrong 
    type of Datum, dividing by zero, mod by zero, not function on integers, and
    invalid inputs like "#" that do not return "not implemented" messages
    but have their own error messages. I found that the demo program has its
    own error message when "#" is inputted without a "t" or "f" afterward, so
    my query loop has its own condition to print the appropriate error message.
    For each function that requires a certain type of input, I tested it by 
    inputting the wrong type of input and calling the function to ensure it 
    printing the correct error message. I also tested by calling rstring on 
    files that call other files within them, which stress tested my program. 
    I also tested the program functionality when the end of a file input is 
    reached as it is supposed to quit when either "quit" is inputted or the 
    end of the input is reached. 

H. Time Spent: 35 hours
